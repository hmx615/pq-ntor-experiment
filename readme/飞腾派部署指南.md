# 🚀 PQ-Tor 飞腾派部署指南

**目标**: 在5个飞腾派上部署完整的PQ-Tor网络
**架构**: ARM64 (飞腾派)
**难度**: ⭐⭐⭐ (中等)

---

## 📋 部署策略

### 分步验证方法

```
Step 1: 环境检查 → 测试脚本验证
Step 2: 依赖安装 → 简单Kyber程序测试
Step 3: 编译验证 → 单个测试程序
Step 4: 完整编译 → 所有程序编译成功
Step 5: 单机测试 → 5个程序在一个派上运行
Step 6: 分布部署 → 5个派协同工作
```

**核心思想**: 每一步都有验证程序，确保成功后再进行下一步！

---

## 🔧 硬件需求

### 飞腾派配置

- **数量**: 5个
- **架构**: ARM64 (aarch64)
- **内存**: 建议 ≥2GB
- **存储**: ≥8GB (实际使用<500MB)
- **网络**: 同一局域网，互相可访问

### 网络规划

| 派编号 | IP地址 | 角色 | 端口 |
|--------|--------|------|------|
| 派1 | 192.168.1.10 | Directory | 5000, 8000 |
| 派2 | 192.168.1.11 | Guard | 6001 |
| 派3 | 192.168.1.12 | Middle | 6002 |
| 派4 | 192.168.1.13 | Exit | 6003 |
| 派5 | 192.168.1.14 | Client | - |

**注意**: IP地址根据您的实际网络环境调整！

---

## 📦 Step 1: 环境检查脚本

### 1.1 创建检查脚本

在每个飞腾派上运行以下脚本：

```bash
#!/bin/bash
# check_env.sh - 飞腾派环境检查脚本

echo "======================================"
echo "  飞腾派环境检查"
echo "======================================"
echo ""

# 检查架构
ARCH=$(uname -m)
echo "[1/8] 检查CPU架构..."
echo "      架构: $ARCH"
if [[ "$ARCH" == "aarch64" || "$ARCH" == "arm64" ]]; then
    echo "      ✅ ARM64架构正确"
else
    echo "      ❌ 错误: 需要ARM64架构，当前是 $ARCH"
    exit 1
fi
echo ""

# 检查操作系统
echo "[2/8] 检查操作系统..."
if [ -f /etc/os-release ]; then
    . /etc/os-release
    echo "      OS: $NAME $VERSION"
    echo "      ✅ Linux系统"
else
    echo "      ❌ 无法识别操作系统"
    exit 1
fi
echo ""

# 检查GCC
echo "[3/8] 检查GCC编译器..."
if command -v gcc &> /dev/null; then
    GCC_VERSION=$(gcc --version | head -n1)
    echo "      $GCC_VERSION"
    echo "      ✅ GCC已安装"
else
    echo "      ❌ GCC未安装"
    echo "      安装: sudo apt-get install build-essential"
    exit 1
fi
echo ""

# 检查Make
echo "[4/8] 检查Make..."
if command -v make &> /dev/null; then
    MAKE_VERSION=$(make --version | head -n1)
    echo "      $MAKE_VERSION"
    echo "      ✅ Make已安装"
else
    echo "      ❌ Make未安装"
    exit 1
fi
echo ""

# 检查CMake
echo "[5/8] 检查CMake..."
if command -v cmake &> /dev/null; then
    CMAKE_VERSION=$(cmake --version | head -n1)
    echo "      $CMAKE_VERSION"
    echo "      ✅ CMake已安装"
else
    echo "      ❌ CMake未安装"
    echo "      安装: sudo apt-get install cmake"
    exit 1
fi
echo ""

# 检查OpenSSL
echo "[6/8] 检查OpenSSL..."
if command -v openssl &> /dev/null; then
    OPENSSL_VERSION=$(openssl version)
    echo "      $OPENSSL_VERSION"
    if pkg-config --exists openssl; then
        echo "      ✅ OpenSSL开发库已安装"
    else
        echo "      ❌ OpenSSL开发库未安装"
        echo "      安装: sudo apt-get install libssl-dev"
        exit 1
    fi
else
    echo "      ❌ OpenSSL未安装"
    exit 1
fi
echo ""

# 检查Git
echo "[7/8] 检查Git..."
if command -v git &> /dev/null; then
    GIT_VERSION=$(git --version)
    echo "      $GIT_VERSION"
    echo "      ✅ Git已安装"
else
    echo "      ❌ Git未安装"
    echo "      安装: sudo apt-get install git"
    exit 1
fi
echo ""

# 检查磁盘空间
echo "[8/8] 检查磁盘空间..."
AVAILABLE=$(df -h . | awk 'NR==2 {print $4}')
echo "      可用空间: $AVAILABLE"
echo "      需要空间: ~500MB"
echo "      ✅ 磁盘空间检查完成"
echo ""

echo "======================================"
echo "  ✅ 环境检查通过！"
echo "======================================"
echo ""
echo "下一步: 安装依赖项"
echo "运行: sudo apt-get install build-essential cmake libssl-dev git"
```

### 1.2 运行检查

```bash
# 保存脚本
cat > check_env.sh << 'EOF'
[粘贴上面的脚本内容]
EOF

# 添加执行权限
chmod +x check_env.sh

# 运行检查
./check_env.sh
```

**预期输出**: 全部显示 ✅，表示环境就绪。

---

## 🔨 Step 2: 安装依赖项

### 2.1 安装系统依赖

```bash
# 更新软件源
sudo apt-get update

# 安装基础工具
sudo apt-get install -y build-essential cmake git

# 安装OpenSSL开发库
sudo apt-get install -y libssl-dev

# 安装其他工具
sudo apt-get install -y wget curl vim
```

### 2.2 编译安装 liboqs (Kyber KEM库)

**这是最关键的步骤！**

```bash
# 1. 创建工作目录
mkdir -p ~/pq-tor-deps
cd ~/pq-tor-deps

# 2. 克隆liboqs
git clone https://github.com/open-quantum-safe/liboqs.git
cd liboqs

# 3. 创建构建目录
mkdir build && cd build

# 4. 配置CMake (安装到 ~/oqs)
cmake -DCMAKE_INSTALL_PREFIX=$HOME/oqs \
      -DCMAKE_BUILD_TYPE=Release \
      -DBUILD_SHARED_LIBS=ON ..

# 5. 编译 (使用所有CPU核心)
make -j$(nproc)

# 6. 安装
make install

# 7. 验证安装
ls -lh ~/oqs/lib/liboqs.so*
```

**预期输出**:
```
-rwxr-xr-x 1 user user 3.2M ... liboqs.so.0.11.0
lrwxrwxrwx 1 user user   16 ... liboqs.so -> liboqs.so.0.11.0
```

---

## ✅ Step 3: 验证测试程序

### 3.1 创建简单的Kyber测试程序

这个程序用于验证liboqs是否能在飞腾派上正常工作：

```bash
# 创建测试目录
mkdir -p ~/pq-tor-test
cd ~/pq-tor-test

# 创建测试程序
cat > test_kyber_simple.c << 'EOF'
/**
 * test_kyber_simple.c - 飞腾派Kyber KEM验证程序
 *
 * 功能: 测试liboqs在ARM64上是否正常工作
 */

#include <stdio.h>
#include <string.h>
#include <oqs/oqs.h>

int main(void) {
    printf("======================================\n");
    printf("  飞腾派Kyber KEM验证程序\n");
    printf("======================================\n\n");

    // 1. 检查Kyber512是否可用
    printf("[1/4] 检查Kyber512算法...\n");
    if (!OQS_KEM_alg_is_enabled("Kyber512")) {
        fprintf(stderr, "      ❌ Kyber512不可用\n");
        return 1;
    }
    printf("      ✅ Kyber512可用\n\n");

    // 2. 创建KEM对象
    printf("[2/4] 创建KEM对象...\n");
    OQS_KEM *kem = OQS_KEM_new("Kyber512");
    if (kem == NULL) {
        fprintf(stderr, "      ❌ 创建KEM失败\n");
        return 1;
    }
    printf("      ✅ KEM对象创建成功\n");
    printf("      公钥大小: %zu bytes\n", kem->length_public_key);
    printf("      密钥大小: %zu bytes\n", kem->length_secret_key);
    printf("      密文大小: %zu bytes\n", kem->length_ciphertext);
    printf("      共享密钥: %zu bytes\n\n", kem->length_shared_secret);

    // 3. 密钥生成
    printf("[3/4] 生成密钥对...\n");
    uint8_t *public_key = malloc(kem->length_public_key);
    uint8_t *secret_key = malloc(kem->length_secret_key);

    if (OQS_KEM_keypair(kem, public_key, secret_key) != OQS_SUCCESS) {
        fprintf(stderr, "      ❌ 密钥生成失败\n");
        OQS_KEM_free(kem);
        return 1;
    }
    printf("      ✅ 密钥对生成成功\n\n");

    // 4. 封装/解封装测试
    printf("[4/4] 测试封装/解封装...\n");
    uint8_t *ciphertext = malloc(kem->length_ciphertext);
    uint8_t *shared_secret_enc = malloc(kem->length_shared_secret);
    uint8_t *shared_secret_dec = malloc(kem->length_shared_secret);

    // 封装
    if (OQS_KEM_encaps(kem, ciphertext, shared_secret_enc, public_key) != OQS_SUCCESS) {
        fprintf(stderr, "      ❌ 封装失败\n");
        goto cleanup;
    }
    printf("      ✅ 封装成功\n");

    // 解封装
    if (OQS_KEM_decaps(kem, shared_secret_dec, ciphertext, secret_key) != OQS_SUCCESS) {
        fprintf(stderr, "      ❌ 解封装失败\n");
        goto cleanup;
    }
    printf("      ✅ 解封装成功\n");

    // 验证共享密钥一致
    if (memcmp(shared_secret_enc, shared_secret_dec, kem->length_shared_secret) != 0) {
        fprintf(stderr, "      ❌ 共享密钥不匹配\n");
        goto cleanup;
    }
    printf("      ✅ 共享密钥匹配\n\n");

    printf("======================================\n");
    printf("  ✅ 所有测试通过！\n");
    printf("  飞腾派环境配置成功！\n");
    printf("======================================\n");

cleanup:
    free(public_key);
    free(secret_key);
    free(ciphertext);
    free(shared_secret_enc);
    free(shared_secret_dec);
    OQS_KEM_free(kem);

    return 0;
}
EOF

# 创建Makefile
cat > Makefile << 'EOF'
CC = gcc
CFLAGS = -Wall -O2 -I$(HOME)/oqs/include
LDFLAGS = -L$(HOME)/oqs/lib -loqs -Wl,-rpath,$(HOME)/oqs/lib

test_kyber_simple: test_kyber_simple.c
	$(CC) $(CFLAGS) -o test_kyber_simple test_kyber_simple.c $(LDFLAGS)

clean:
	rm -f test_kyber_simple

.PHONY: clean
EOF
```

### 3.2 编译并运行测试

```bash
# 编译
make

# 运行测试
./test_kyber_simple
```

### 3.3 预期输出

```
======================================
  飞腾派Kyber KEM验证程序
======================================

[1/4] 检查Kyber512算法...
      ✅ Kyber512可用

[2/4] 创建KEM对象...
      ✅ KEM对象创建成功
      公钥大小: 800 bytes
      密钥大小: 1632 bytes
      密文大小: 768 bytes
      共享密钥: 32 bytes

[3/4] 生成密钥对...
      ✅ 密钥对生成成功

[4/4] 测试封装/解封装...
      ✅ 封装成功
      ✅ 解封装成功
      ✅ 共享密钥匹配

======================================
  ✅ 所有测试通过！
  飞腾派环境配置成功！
======================================
```

**如果看到这个输出，说明飞腾派环境完全就绪，可以编译完整的PQ-Tor代码！**

---

## 📥 Step 4: 部署完整PQ-Tor代码

### 4.1 传输代码到飞腾派

**方式1: 使用Git**
```bash
# 在飞腾派上
cd ~
git clone [your-repo-url]
cd pq-ntor-experiment/c
```

**方式2: 使用SCP传输**
```bash
# 在开发机上（WSL）
cd /home/ccc/pq-ntor-experiment
tar czf pq-tor.tar.gz c/

# 传输到飞腾派
scp pq-tor.tar.gz user@192.168.1.10:~/

# 在飞腾派上解压
ssh user@192.168.1.10
cd ~
tar xzf pq-tor.tar.gz
cd c/
```

### 4.2 修改Makefile路径

编辑 `Makefile`，修改liboqs路径：

```makefile
# 原来的路径（WSL）
LIBOQS_DIR = $(HOME)/_oqs

# 改为飞腾派的路径
LIBOQS_DIR = $(HOME)/oqs
```

或者直接使用环境变量：

```bash
export LIBOQS_DIR=$HOME/oqs
make all
```

### 4.3 编译所有程序

```bash
# 清理旧的编译文件
make clean

# 编译所有程序
make all
```

**预期结果**:
```
✓ Built: test_kyber
✓ Built: test_crypto
✓ Built: test_pq_ntor
✓ Built: test_cell
✓ Built: test_onion
✓ Built: benchmark_pq_ntor
✓ Built: directory
✓ Built: relay
✓ Built: client
```

### 4.4 运行单元测试

```bash
# 测试所有模块
./test_kyber && echo "✅ Kyber OK"
./test_crypto && echo "✅ Crypto OK"
./test_pq_ntor && echo "✅ PQ-Ntor OK"
./test_cell && echo "✅ Cell OK"
./test_onion && echo "✅ Onion OK"
```

**所有测试应该输出**: `✅ All tests passed!`

---

## 🌐 Step 5: 单机测试（在一个派上）

在部署到5个派之前，先在一个派上测试所有程序能否协同工作：

```bash
cd ~/pq-ntor-experiment/c

# 运行完整网络测试
./test_network.sh
```

**预期**: 客户端成功接收HTTP响应

---

## 🚀 Step 6: 5节点分布式部署

### 6.1 节点配置文件

每个派需要不同的配置：

**派1 (Directory)**:
```bash
# 启动目录服务器
./directory
```

**派2 (Guard)**:
```bash
# 启动Guard节点
./relay -r guard -p 6001
```

**派3 (Middle)**:
```bash
# 启动Middle节点
./relay -r middle -p 6002
```

**派4 (Exit)**:
```bash
# 启动Exit节点
./relay -r exit -p 6003
```

**派5 (Client)**:
```bash
# 修改客户端代码中的IP地址
# 将所有 127.0.0.1 改为实际IP
# 运行客户端
./client http://192.168.1.10:8000
```

### 6.2 配置文件修改

在部署前需要修改以下文件中的IP地址：

**`src/directory_server.c`** (派1):
```c
// 无需修改，监听0.0.0.0
```

**客户端配置** (派5):
修改 `programs/client_main.c`:
```c
tor_client_config_t config = {
    .directory_host = "192.168.1.10",  // Directory的IP
    .directory_port = 5000,
    .timeout_seconds = 30
};
```

修改目录服务器返回的节点列表 `src/directory_server.c`:
```c
// 修改节点IP为实际IP
"\"hostname\": \"192.168.1.11\", \"port\": 6001"  // Guard
"\"hostname\": \"192.168.1.12\", \"port\": 6002"  // Middle
"\"hostname\": \"192.168.1.13\", \"port\": 6003"  // Exit
```

---

## ✅ 验证清单

### 每个飞腾派完成后检查：

- [ ] 环境检查脚本通过 (`./check_env.sh`)
- [ ] liboqs编译安装成功
- [ ] 简单Kyber测试通过 (`./test_kyber_simple`)
- [ ] 完整代码编译成功 (`make all`)
- [ ] 所有单元测试通过
- [ ] (派1) 单机5程序测试通过 (`./test_network.sh`)
- [ ] 网络连通性测试 (`ping 其他派`)
- [ ] 防火墙端口开放 (5000, 6001-6003, 8000)

---

## 🐛 常见问题

### Q1: liboqs编译失败
**解决**: 确保安装了cmake和build-essential

### Q2: 找不到liboqs.so
**解决**: 设置LD_LIBRARY_PATH
```bash
export LD_LIBRARY_PATH=$HOME/oqs/lib:$LD_LIBRARY_PATH
```

### Q3: 网络连接失败
**解决**: 检查防火墙，开放端口
```bash
sudo ufw allow 5000,6001,6002,6003,8000/tcp
```

### Q4: 交叉编译？
**答**: 不需要！直接在飞腾派上编译即可。

---

## 📞 需要帮助？

如果遇到问题：
1. 检查环境检查脚本输出
2. 运行简单Kyber测试
3. 查看编译错误信息
4. 检查网络连通性

**成功标志**: 简单Kyber测试通过 = 环境100%就绪！

---

**创建时间**: 2025-11-06
**适用平台**: 飞腾派 (ARM64)
**预计部署时间**: 每个派 30-60分钟
