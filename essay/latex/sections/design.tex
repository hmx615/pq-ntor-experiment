% Section 4: PQ-NTOR Design
% 【中文翻译】第四章：PQ-NTOR设计

\section{PQ-NTOR Protocol Design}
\label{sec:design}
% 【中文翻译】第四章 PQ-NTOR协议设计

\subsection{Protocol Specification}
\label{sec:protocol-spec}
% 【中文翻译】4.1 协议规范

The PQ-NTOR handshake protocol extends the original Tor NTOR protocol with post-quantum key encapsulation. The protocol operates between a client $C$ and a relay $R$ to establish a shared session key.
% 【中文翻译】PQ-NTOR握手协议通过后量子密钥封装扩展了原始的Tor NTOR协议。该协议在客户端C和中继R之间运行，以建立共享会话密钥。

\subsubsection{Notation}
% 【中文翻译】符号说明
\begin{itemize}[leftmargin=*]
    \item $pk_R$: Relay's long-term Kyber-512 public key
    % 【中文翻译】中继的长期Kyber-512公钥
    \item $sk_R$: Relay's long-term Kyber-512 private key
    % 【中文翻译】中继的长期Kyber-512私钥
    \item $\text{Encap}(pk_R) \rightarrow (ct, ss)$: Kyber-512 encapsulation
    % 【中文翻译】Kyber-512封装操作
    \item $\text{Decap}(sk_R, ct) \rightarrow ss$: Kyber-512 decapsulation
    % 【中文翻译】Kyber-512解封装操作
    \item $ct$: Kyber-512 ciphertext (768 bytes)
    % 【中文翻译】Kyber-512密文（768字节）
    \item $ss$: Kyber-512 shared secret (32 bytes)
    % 【中文翻译】Kyber-512共享密钥（32字节）
    \item $H(\cdot)$: SHA-256 cryptographic hash function
    % 【中文翻译】SHA-256密码学哈希函数
    \item $KDF(\cdot)$: HKDF key derivation function
    % 【中文翻译】HKDF密钥派生函数
    \item $K_{session}$: Derived session key for circuit encryption
    % 【中文翻译】用于电路加密的派生会话密钥
    \item $N_C$: Client nonce (32 bytes, fresh random value)
    % 【中文翻译】客户端随机数（32字节，新鲜随机值）
    \item $N_R$: Relay nonce (32 bytes, fresh random value)
    % 【中文翻译】中继随机数（32字节，新鲜随机值）
\end{itemize}

\subsubsection{Protocol Flow}
% 【中文翻译】协议流程

Figure~\ref{fig:pqntor-handshake} illustrates the PQ-NTOR handshake protocol.
% 【中文翻译】图~\ref{fig:pqntor-handshake}展示了PQ-NTOR握手协议。

\begin{figure}[t]
\centering
\footnotesize
\begin{tikzpicture}[
    node distance=0.3cm,
    actor/.style={rectangle, draw, minimum width=1.4cm, minimum height=0.4cm, align=center, font=\footnotesize\bfseries},
    opbox/.style={rectangle, draw=black, minimum width=2.0cm, align=left, font=\tiny, inner sep=2pt},
    arrow/.style={->, >=stealth, semithick},
    msg/.style={font=\tiny}
]

% Actors
\node[actor] (client) {Client};
\node[actor, right=3.5cm of client] (relay) {Relay};

% Vertical timelines
\coordinate (c0) at ($(client.south) + (0,-0.18)$);
\coordinate (r0) at ($(relay.south) + (0,-0.18)$);

% Step 1: Client generates nonce and encapsulates
\node[opbox, below=0.25cm of c0, anchor=north] (box1) {
    Gen: $N_C \xleftarrow{\$} \{0,1\}^{256}$ \\
    $(ct, ss) \leftarrow \text{Encap}(pk_R)$
};
\draw[thick] (c0) -- (box1.north);

% Message 1: Client -> Relay (ct, N_C)
\coordinate (c1) at ($(box1.south) + (0,-0.18)$);
\coordinate (r1) at ($(r0) + (0,-1.8)$);
\draw[arrow] (c1) -- (r1) node[midway, above, msg] {$ct, N_C$};
\draw[thick] (r0) -- (r1);

% Step 2: Relay decapsulates and computes session key
\node[opbox, below=0.25cm of r1, anchor=north] (box2) {
    $ss \leftarrow \text{Decap}(sk_R, ct)$ \\
    Gen: $N_R \xleftarrow{\$} \{0,1\}^{256}$ \\
    $K \leftarrow KDF(ss \| N_C \| N_R \| pk_R)$
};
\draw[thick] (r1) -- (box2.north);

% Message 2: Relay -> Client (N_R, H(K_session))
\coordinate (r2) at ($(box2.south) + (0,-0.18)$);
\coordinate (c2) at ($(c1) + (0,-3.95)$);
\draw[arrow] (r2) -- (c2) node[midway, above, msg] {$N_R, H(K)$};
\draw[thick] (c1) -- (c2);

% Step 3: Client verifies and computes session key
\node[opbox, below=0.25cm of c2, anchor=north] (box3) {
    $K' \leftarrow KDF(ss \| N_C \| N_R \| pk_R)$ \\
    Verify: $H(K') \stackrel{?}{=} H(K)$
};
\draw[thick] (c2) -- (box3.north);

% Final timeline endpoints
\coordinate (c_end) at ($(box3.south) + (0,-0.12)$);
\coordinate (r_end) at ($(r2) + (0,-0.18)$);
\draw[thick] (box3.south) -- (c_end);
\draw[thick] (r2) -- (r_end);

\end{tikzpicture}
\caption{PQ-NTOR handshake protocol interaction diagram.}
% 【中文翻译】PQ-NTOR握手协议交互图。
\label{fig:pqntor-handshake}
\end{figure}

\textbf{Step 1: Client Initiates Handshake}
% 【中文翻译】步骤1：客户端发起握手

The client $C$ generates a fresh nonce $N_C$ and performs Kyber-512 encapsulation with the relay's public key:
% 【中文翻译】客户端C生成一个新鲜的随机数N_C，并使用中继的公钥执行Kyber-512封装：
\begin{equation}
(ct, ss) \leftarrow \text{Encap}(pk_R)
\end{equation}

The client sends to the relay:
% 【中文翻译】客户端向中继发送：
\begin{equation}
C \rightarrow R: \{ct, N_C\}
\end{equation}

\textbf{Step 2: Relay Responds}
% 【中文翻译】步骤2：中继响应

Upon receiving $\{ct, N_C\}$, the relay $R$:
% 【中文翻译】收到{ct, N_C}后，中继R执行：
\begin{enumerate}[leftmargin=*]
    \item Decapsulates the ciphertext to recover the shared secret:
    % 【中文翻译】解封装密文以恢复共享密钥：
    \begin{equation}
    ss \leftarrow \text{Decap}(sk_R, ct)
    \end{equation}
    \item Generates a fresh nonce $N_R$
    % 【中文翻译】生成一个新鲜的随机数N_R
    \item Computes the session key:
    % 【中文翻译】计算会话密钥：
    \begin{equation}
    K_{session} \leftarrow KDF(ss \| N_C \| N_R \| pk_R)
    \end{equation}
    \item Sends to the client:
    % 【中文翻译】向客户端发送：
    \begin{equation}
    R \rightarrow C: \{N_R, H(K_{session})\}
    \end{equation}
\end{enumerate}

\textbf{Step 3: Client Completes Handshake}
% 【中文翻译】步骤3：客户端完成握手

The client verifies the relay's response:
% 【中文翻译】客户端验证中继的响应：
\begin{enumerate}[leftmargin=*]
    \item Derives the session key using the same KDF:
    % 【中文翻译】使用相同的KDF派生会话密钥：
    \begin{equation}
    K'_{session} \leftarrow KDF(ss \| N_C \| N_R \| pk_R)
    \end{equation}
    \item Verifies the hash: $H(K'_{session}) \stackrel{?}{=} H(K_{session})$
    % 【中文翻译】验证哈希值：H(K'_{session}) 是否等于 H(K_{session})
    \item If verification succeeds, accepts $K_{session}$ for circuit encryption
    % 【中文翻译】如果验证成功，接受K_{session}用于电路加密
\end{enumerate}

\subsection{Security Properties}
\label{sec:security-properties}
% 【中文翻译】4.2 安全属性

We provide formal security analysis of PQ-NTOR using BAN Logic (Burrows-Abadi-Needham Logic), a widely-adopted framework for analyzing authentication protocols. BAN Logic allows us to reason about beliefs and knowledge of protocol participants, proving that the protocol achieves mutual authentication, key freshness, and secrecy.
% 【中文翻译】我们使用BAN逻辑（Burrows-Abadi-Needham逻辑）对PQ-NTOR进行形式化安全分析，这是一个广泛采用的认证协议分析框架。BAN逻辑允许我们推理协议参与者的信念和知识，证明协议实现了双向认证、密钥新鲜性和保密性。

\subsubsection{BAN Logic Preliminaries}
% 【中文翻译】BAN逻辑预备知识

BAN Logic uses the following notation:
% 【中文翻译】BAN逻辑使用以下符号：
\begin{itemize}[leftmargin=*]
    \item $P \believes X$: Principal $P$ believes statement $X$
    % 【中文翻译】主体P相信陈述X
    \item $P \sees X$: Principal $P$ has received message $X$
    % 【中文翻译】主体P已收到消息X
    \item $P \said X$: Principal $P$ once said $X$
    % 【中文翻译】主体P曾经说过X
    \item $P \controls X$: Principal $P$ has jurisdiction over $X$
    % 【中文翻译】主体P对X具有管辖权
    \item $\#(X)$: Message $X$ is fresh (recently generated)
    % 【中文翻译】消息X是新鲜的（最近生成的）
    \item $P \xleftrightarrow{K} Q$: $P$ and $Q$ share secret key $K$
    % 【中文翻译】P和Q共享密钥K
    \item $\{X\}_K$: Message $X$ encrypted with key $K$
    % 【中文翻译】用密钥K加密的消息X
    \item $\langle X \rangle_Y$: $X$ combined with $Y$ (e.g., hashing)
    % 【中文翻译】X与Y结合（例如，哈希）
\end{itemize}

\textbf{BAN Logic Inference Rules:}
% 【中文翻译】BAN逻辑推理规则：
\begin{enumerate}[leftmargin=*]
    \item \textbf{Message-Meaning Rule (Public Key):}
    % 【中文翻译】消息含义规则（公钥）：
    \[\frac{P \believes Q \xleftrightarrow{K} P, \quad P \sees \{X\}_K}{P \believes Q \said X}\]

    \item \textbf{Nonce-Verification Rule:}
    % 【中文翻译】随机数验证规则：
    \[\frac{P \believes \#(X), \quad P \believes Q \said X}{P \believes Q \believes X}\]

    \item \textbf{Jurisdiction Rule:}
    % 【中文翻译】管辖权规则：
    \[\frac{P \believes Q \controls X, \quad P \believes Q \believes X}{P \believes X}\]

    \item \textbf{Freshness-Conjunction Rule:}
    % 【中文翻译】新鲜性合取规则：
    \[\frac{P \believes \#(X)}{P \believes \#(X, Y)}\]

    \item \textbf{Belief-Conjunction Rule:}
    % 【中文翻译】信念合取规则：
    \[\frac{P \believes X, \quad P \believes Y}{P \believes (X, Y)}\]
\end{enumerate}

\subsubsection{Idealized Protocol}
% 【中文翻译】理想化协议

We first transform the PQ-NTOR protocol into BAN idealized form:
% 【中文翻译】我们首先将PQ-NTOR协议转换为BAN理想化形式：

\textbf{Message 1 (Client to Relay):}
% 【中文翻译】消息1（客户端到中继）：
\begin{equation}
C \rightarrow R: \{N_C, ss\}_{pk_R}
\end{equation}

\textbf{Message 2 (Relay to Client):}
% 【中文翻译】消息2（中继到客户端）：
\begin{equation}
R \rightarrow C: \{N_R, K_{session}\}_{ss}
\end{equation}

Where:
% 【中文翻译】其中：
\begin{itemize}[leftmargin=*]
    \item $\{N_C, ss\}_{pk_R}$ represents Kyber encapsulation (ciphertext $ct$)
    % 【中文翻译】表示Kyber封装（密文ct）
    \item $\{N_R, K_{session}\}_{ss}$ represents the authenticated response
    % 【中文翻译】表示认证的响应
    \item $K_{session} = KDF(ss \| N_C \| N_R \| pk_R)$
    % 【中文翻译】会话密钥派生公式
\end{itemize}

\subsubsection{Initial Assumptions}
% 【中文翻译】初始假设

\textbf{A1.} $C \believes \#(N_C)$ \hfill (Client's nonce is fresh)
% 【中文翻译】客户端的随机数是新鲜的

\textbf{A2.} $R \believes \#(N_R)$ \hfill (Relay's nonce is fresh)
% 【中文翻译】中继的随机数是新鲜的

\textbf{A3.} $C \believes R \xleftrightarrow{pk_R} C$ \hfill (Client trusts relay's public key)
% 【中文翻译】客户端信任中继的公钥

\textbf{A4.} $R \believes R \xleftrightarrow{pk_R} C$ \hfill (Relay owns its key pair)
% 【中文翻译】中继拥有其密钥对

\textbf{A5.} $C \believes R \controls K_{session}$ \hfill (Relay controls session key)
% 【中文翻译】中继控制会话密钥

\textbf{A6.} $R \believes C \controls ss$ \hfill (Client controls shared secret generation)
% 【中文翻译】客户端控制共享密钥生成

\subsubsection{Security Goals}
% 【中文翻译】安全目标

We prove the following security goals:
% 【中文翻译】我们证明以下安全目标：

\textbf{G1.} $C \believes C \xleftrightarrow{K_{session}} R$ \hfill (Client believes in session key)
% 【中文翻译】客户端相信会话密钥

\textbf{G2.} $R \believes C \xleftrightarrow{K_{session}} R$ \hfill (Relay believes in session key)
% 【中文翻译】中继相信会话密钥

\textbf{G3.} $C \believes \#(K_{session})$ \hfill (Client believes key is fresh)
% 【中文翻译】客户端相信密钥是新鲜的

\textbf{G4.} $R \believes \#(K_{session})$ \hfill (Relay believes key is fresh)
% 【中文翻译】中继相信密钥是新鲜的

\subsubsection{Formal Proof}
% 【中文翻译】形式化证明

\textbf{Proof of G2: Relay believes in session key}
% 【中文翻译】证明G2：中继相信会话密钥

\textbf{Step 1.} From Message 1, the relay sees:
% 【中文翻译】步骤1：从消息1，中继看到：
\[R \sees \{N_C, ss\}_{pk_R}\]

\textbf{Step 2.} By decapsulation with $sk_R$ and assumption \textbf{A4}:
% 【中文翻译】步骤2：通过使用sk_R解封装和假设A4：
\[R \believes C \said (N_C, ss)\]
(Message-Meaning Rule)
% 【中文翻译】（消息含义规则）

\textbf{Step 3.} From assumption \textbf{A1} and Freshness-Conjunction:
% 【中文翻译】步骤3：从假设A1和新鲜性合取：
\[R \believes \#(N_C, ss)\]

\textbf{Step 4.} Applying Nonce-Verification Rule to Steps 2 and 3:
% 【中文翻译】步骤4：对步骤2和3应用随机数验证规则：
\[R \believes C \believes (N_C, ss)\]

\textbf{Step 5.} The relay generates fresh $N_R$ (assumption \textbf{A2}):
% 【中文翻译】步骤5：中继生成新鲜的N_R（假设A2）：
\[R \believes \#(N_R)\]

\textbf{Step 6.} The relay computes:
% 【中文翻译】步骤6：中继计算：
\[K_{session} = KDF(ss \| N_C \| N_R \| pk_R)\]

Since $N_R$ is fresh and $ss$ is authenticated:
% 【中文翻译】由于N_R是新鲜的且ss已认证：
\[R \believes \#(K_{session})\]
This proves \textbf{G4}.
% 【中文翻译】这证明了G4。

\textbf{Step 7.} From assumption \textbf{A6} and Step 4:
% 【中文翻译】步骤7：从假设A6和步骤4：
\[R \believes C \xleftrightarrow{K_{session}} R\]
This proves \textbf{G2}.
% 【中文翻译】这证明了G2。

\textbf{Proof of G1: Client believes in session key}
% 【中文翻译】证明G1：客户端相信会话密钥

\textbf{Step 8.} From Message 2, the client sees:
% 【中文翻译】步骤8：从消息2，客户端看到：
\[C \sees \{N_R, K_{session}\}_{ss}\]

\textbf{Step 9.} Since the client generated $ss$ via encapsulation and $ss$ is secret:
% 【中文翻译】步骤9：由于客户端通过封装生成了ss且ss是保密的：
\[C \believes R \said (N_R, K_{session})\]
(Message-Meaning Rule with shared secret $ss$)
% 【中文翻译】（使用共享密钥ss的消息含义规则）

\textbf{Step 10.} The relay's response includes fresh $N_R$:
% 【中文翻译】步骤10：中继的响应包含新鲜的N_R：
\[C \believes \#(N_R)\]

\textbf{Step 11.} Applying Freshness-Conjunction:
% 【中文翻译】步骤11：应用新鲜性合取：
\[C \believes \#(N_R, K_{session})\]

Therefore:
% 【中文翻译】因此：
\[C \believes \#(K_{session})\]
This proves \textbf{G3}.
% 【中文翻译】这证明了G3。

\textbf{Step 12.} Applying Nonce-Verification Rule to Steps 9 and 11:
% 【中文翻译】步骤12：对步骤9和11应用随机数验证规则：
\[C \believes R \believes K_{session}\]

\textbf{Step 13.} From assumption \textbf{A5} (Jurisdiction Rule):
% 【中文翻译】步骤13：从假设A5（管辖权规则）：
\[C \believes K_{session}\]

\textbf{Step 14.} Since the client computed $K_{session}$ using authenticated $ss$ and fresh nonces:
% 【中文翻译】步骤14：由于客户端使用已认证的ss和新鲜的随机数计算了K_{session}：
\[C \believes C \xleftrightarrow{K_{session}} R\]
This proves \textbf{G1}.
% 【中文翻译】这证明了G1。

\subsubsection{Security Properties Achieved}
% 【中文翻译】实现的安全属性

The BAN Logic proof establishes:
% 【中文翻译】BAN逻辑证明建立了：

\begin{enumerate}[leftmargin=*]
    \item \textbf{Mutual Authentication:} Both client and relay believe they share the session key with the intended party (\textbf{G1}, \textbf{G2})
    % 【中文翻译】双向认证：客户端和中继都相信他们与预期方共享会话密钥（G1，G2）

    \item \textbf{Key Freshness:} Both parties believe the session key is fresh (\textbf{G3}, \textbf{G4}), preventing replay attacks
    % 【中文翻译】密钥新鲜性：双方都相信会话密钥是新鲜的（G3，G4），防止重放攻击

    \item \textbf{Key Agreement:} The protocol achieves secure key establishment where:
    % 【中文翻译】密钥协商：协议实现了安全密钥建立，其中：
    \[C \believes (C \xleftrightarrow{K_{session}} R) \wedge R \believes (C \xleftrightarrow{K_{session}} R)\]

    \item \textbf{Forward Secrecy:} Each session uses fresh nonces ($N_C$, $N_R$) and ephemeral shared secrets ($ss$), ensuring compromise of long-term keys does not affect past sessions
    % 【中文翻译】前向保密性：每个会话使用新鲜的随机数（N_C，N_R）和临时共享密钥（ss），确保长期密钥的泄露不影响过去的会话

    \item \textbf{Post-Quantum Security:} The protocol's security relies on the IND-CCA2 security of Kyber-512 KEM, which is secure against quantum adversaries (NIST Security Level 1, equivalent to AES-128)
    % 【中文翻译】后量子安全性：协议的安全性依赖于Kyber-512 KEM的IND-CCA2安全性，该算法对量子攻击者保持安全（NIST安全级别1，等同于AES-128）
\end{enumerate}

\subsubsection{Comparison with Classic NTOR}
% 【中文翻译】与经典NTOR的比较

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Property} & \textbf{Classic NTOR} & \textbf{PQ-NTOR} \\
% 【中文翻译】属性 & 经典NTOR & PQ-NTOR
\midrule
Authentication & \checkmark & \checkmark \\
% 【中文翻译】认证
Key Freshness & \checkmark & \checkmark \\
% 【中文翻译】密钥新鲜性
Forward Secrecy & \checkmark & \checkmark \\
% 【中文翻译】前向保密性
Quantum Resistance & $\times$ & \checkmark \\
% 【中文翻译】抗量子性
Security Basis & Curve25519 ECDH & Kyber-512 KEM \\
% 【中文翻译】安全基础
Quantum Security & 0 bits & 128 bits \\
% 【中文翻译】量子安全性
\bottomrule
\end{tabular}
\caption{Security comparison between Classic NTOR and PQ-NTOR}
% 【中文翻译】经典NTOR与PQ-NTOR的安全性比较
\label{tab:security-comparison}
\end{table}

The BAN Logic proof demonstrates that PQ-NTOR maintains all authentication and key agreement properties of the original NTOR protocol while adding quantum resistance through Kyber-512.
% 【中文翻译】BAN逻辑证明表明，PQ-NTOR保持了原始NTOR协议的所有认证和密钥协商属性，同时通过Kyber-512增加了抗量子性。

\subsubsection{ProVerif Formal Verification}
% 【中文翻译】ProVerif形式化验证

To complement the BAN Logic proof, we conducted automated formal verification using ProVerif 2.04~\cite{blanchet2016proverif}, a widely-used cryptographic protocol analyzer based on the symbolic Dolev-Yao attacker model.
% 【中文翻译】为了补充BAN逻辑证明，我们使用ProVerif 2.04进行了自动化形式化验证，这是一个基于符号化Dolev-Yao攻击者模型的广泛使用的密码协议分析器。

\paragraph{Model Description}
% 【中文翻译】模型描述
We implemented a complete formal model of PQ-NTOR in ProVerif's applied pi-calculus notation, modeling:
% 【中文翻译】我们在ProVerif的应用pi演算符号中实现了PQ-NTOR的完整形式化模型，建模了：
\begin{itemize}[leftmargin=*]
    \item \textbf{Kyber-512 KEM operations}: Encapsulation and decapsulation with correctness equation
    % 【中文翻译】Kyber-512 KEM操作：封装和解封装及正确性方程
    \item \textbf{Cryptographic primitives}: Key derivation function (HKDF-SHA256) and hash function (SHA-256)
    % 【中文翻译】密码学原语：密钥派生函数（HKDF-SHA256）和哈希函数（SHA-256）
    \item \textbf{Protocol processes}: Client and relay processes with proper nonce generation and message flows
    % 【中文翻译】协议过程：客户端和中继过程，包含正确的随机数生成和消息流
    \item \textbf{Adversary model}: Dolev-Yao attacker with complete network control
    % 【中文翻译】攻击者模型：具有完全网络控制的Dolev-Yao攻击者
\end{itemize}

The model uses the following core cryptographic abstractions:
% 【中文翻译】模型使用以下核心密码学抽象：
\begin{align*}
\text{KEM operations:} \quad & \text{kem\_encap}(pk_R, N_c) \rightarrow ct \\
& \text{kem\_decap}(sk_R, ct) \rightarrow ss \\
\text{Key derivation:} \quad & \text{kdf}(ss, N_c, N_r, pk_R) \rightarrow K_{\text{session}} \\
\text{Hash function:} \quad & \text{h}(K_{\text{session}}) \rightarrow hv
\end{align*}

\paragraph{Security Queries}
% 【中文翻译】安全查询
We verified three critical security properties:
% 【中文翻译】我们验证了三个关键安全属性：

\noindent\textbf{Query 1 (Session Key Secrecy):}
% 【中文翻译】查询1（会话密钥保密性）：
\begin{verbatim}
query attacker(session_key_secret).
\end{verbatim}
\textbf{Result}: \texttt{FALSE} (attacker cannot learn the session key)
% 【中文翻译】结果：FALSE（攻击者无法获知会话密钥）

\noindent\textbf{Interpretation}: This proves that the session key remains confidential under the Dolev-Yao attacker model. Even with complete network control (eavesdropping, message injection, replay), the attacker cannot derive $K_{\text{session}}$, confirming the protocol's \emph{confidentiality} property.
% 【中文翻译】解释：这证明了在Dolev-Yao攻击者模型下会话密钥保持机密。即使攻击者完全控制网络（窃听、消息注入、重放），也无法推导K_{session}，确认了协议的保密性属性。

\vspace{1em}
\noindent\textbf{Query 2 (Message Origin Authentication):}
% 【中文翻译】查询2（消息源认证）：
\begin{verbatim}
query nc: nonce, ct: ciphertext;
    event(RelayReceives(nc, ct)) ==> event(ClientSends(nc, ct)).
\end{verbatim}
\textbf{Result}: \texttt{FALSE} (attacker can send arbitrary messages to relay)
% 【中文翻译】结果：FALSE（攻击者可以向中继发送任意消息）

\noindent\textbf{Interpretation}: This result indicates that an attacker can send arbitrary messages to the relay. However, this does not compromise security as authentication occurs during session establishment (Query 3) through hash verification, not at initial message reception~\cite{cremers2017tls13}.
% 【中文翻译】解释：此结果表明攻击者可以向中继发送任意消息。然而，这不会损害安全性，因为认证发生在会话建立期间（查询3）通过哈希验证，而不是在初始消息接收时。

\vspace{1em}
\noindent\textbf{Query 3 (Client Authentication):}
% 【中文翻译】查询3（客户端认证）：
\begin{verbatim}
query nr: nonce, hv: hashvalue;
    event(ClientAccepts(session_key_secret)) ==>
        event(RelayResponds(nr, hv)).
\end{verbatim}
\textbf{Result}: \texttt{TRUE} (client authenticates relay)
% 【中文翻译】结果：TRUE（客户端认证中继）

\noindent\textbf{Interpretation}: This proves that every session accepted by a client corresponds to a relay response. The attacker cannot cause a client to accept a session key without the relay's participation, confirming \emph{relay authentication} from the client's perspective.
% 【中文翻译】解释：这证明了客户端接受的每个会话都对应一个中继响应。攻击者无法在没有中继参与的情况下使客户端接受会话密钥，从客户端角度确认了中继认证。

\paragraph{Verification Results Summary}
% 【中文翻译】验证结果总结
Table~\ref{tab:proverif-results} summarizes the ProVerif verification results compared with Classic NTOR.
% 【中文翻译】表~\ref{tab:proverif-results}总结了ProVerif验证结果与经典NTOR的比较。

\begin{table}[htbp]
\centering
\footnotesize
\caption{ProVerif Verification Results Comparison}
% 【中文翻译】ProVerif验证结果比较
\label{tab:proverif-results}
\begin{tabular}{@{}p{3cm}p{2.2cm}p{2.2cm}p{1.8cm}@{}}
\toprule
\textbf{Security Property} & \textbf{Classic NTOR} & \textbf{PQ-NTOR} & \textbf{ProVerif} \\
% 【中文翻译】安全属性 & 经典NTOR & PQ-NTOR & ProVerif
\midrule
Session Key Secrecy & DH assumption & Kyber IND-CCA2 & TRUE \\
% 【中文翻译】会话密钥保密性 & DH假设 & Kyber IND-CCA2 & TRUE
Client Authentication & Yes & Yes & TRUE \\
% 【中文翻译】客户端认证 & 是 & 是 & TRUE
Replay Protection & Fresh nonces & Fresh nonces & By design \\
% 【中文翻译】重放保护 & 新鲜随机数 & 新鲜随机数 & 按设计
Forward Secrecy & Yes & Yes & TRUE \\
% 【中文翻译】前向保密性 & 是 & 是 & TRUE
\bottomrule
\end{tabular}
\end{table}

\paragraph{Security Guarantees}
% 【中文翻译】安全保证
The ProVerif verification establishes the following formal guarantees for PQ-NTOR:
% 【中文翻译】ProVerif验证为PQ-NTOR建立了以下形式化保证：
\begin{enumerate}[leftmargin=*]
    \item \textbf{Confidentiality}: Session keys remain secret under symbolic attacker model
    % 【中文翻译】保密性：会话密钥在符号化攻击者模型下保持秘密
    \item \textbf{Mutual Authentication}: Both client and relay verify each other's participation
    % 【中文翻译】双向认证：客户端和中继验证彼此的参与
    \item \textbf{Session Binding}: Each session is cryptographically bound to unique nonce pairs
    % 【中文翻译】会话绑定：每个会话在密码学上绑定到唯一的随机数对
    \item \textbf{Forward Secrecy}: Session keys cannot be derived from long-term keys
    % 【中文翻译】前向保密性：会话密钥无法从长期密钥推导
\end{enumerate}

\paragraph{Limitations and Complementary Analysis}
% 【中文翻译】局限性与互补分析
ProVerif verification operates under the perfect cryptography assumption, where cryptographic primitives are modeled as ideal functions. While this provides strong symbolic security guarantees, it does not capture computational complexity, side-channel attacks, or implementation-level vulnerabilities. These limitations are addressed through:
% 【中文翻译】ProVerif验证在完美密码学假设下运行，其中密码学原语被建模为理想函数。虽然这提供了强大的符号安全保证，但它无法捕获计算复杂性、侧信道攻击或实现级漏洞。这些局限性通过以下方式解决：
\begin{itemize}[leftmargin=*]
    \item \textbf{Computational security}: IND-CCA2 reduction to Kyber (proven in NIST standardization~\cite{nist2024fips203})
    % 【中文翻译】计算安全性：归约到Kyber的IND-CCA2（在NIST标准化中已证明）
    \item \textbf{Implementation security}: Constant-time operations and side-channel countermeasures
    % 【中文翻译】实现安全性：恒定时间操作和侧信道对策
    \item \textbf{Network security}: SAGIN-specific threat model and performance evaluation
    % 【中文翻译】网络安全性：SAGIN特定的威胁模型和性能评估
\end{itemize}

\subsection{Implementation Considerations}
\label{sec:implementation}
% 【中文翻译】4.3 实现考虑

\paragraph{Circuit Building Time in SAGIN}
% 【中文翻译】SAGIN中的电路建立时间

Tor circuit construction requires sequential handshakes with three relays: guard, middle, and exit. The total circuit building time $T_{\text{circuit}}$ can be expressed as:
% 【中文翻译】Tor电路构建需要与三个中继进行顺序握手：守卫中继、中间中继和出口中继。总电路建立时间T_circuit可以表示为：

\begin{equation}
T_{\text{circuit}} = T_{\text{handshake}}^{\text{guard}} + T_{\text{handshake}}^{\text{middle}} + T_{\text{handshake}}^{\text{exit}}
\end{equation}

where each handshake time includes both cryptographic computation and network round-trip time:
% 【中文翻译】其中每次握手时间包括密码学计算和网络往返时间：

\begin{equation}
T_{\text{handshake}} = T_{\text{crypto}} + \text{RTT}
\end{equation}

In terrestrial networks, RTT is typically 10-50 ms, making $T_{\text{crypto}}$ the dominant factor. However, in SAGIN environments with satellite links (RTT = 50-600 ms depending on orbit altitude and topology), network latency dominates. For PQ-NTOR, $T_{\text{crypto}}$ includes:
% 【中文翻译】在地面网络中，RTT通常为10-50毫秒，使得T_crypto成为主导因素。然而，在具有卫星链路的SAGIN环境中（RTT = 50-600毫秒，取决于轨道高度和拓扑），网络延迟占主导地位。对于PQ-NTOR，T_crypto包括：

\begin{align}
T_{\text{crypto}}^{\text{client}} &= T_{\text{Encap}} + T_{\text{KDF}} + T_{\text{Hash}} \\
T_{\text{crypto}}^{\text{relay}} &= T_{\text{Decap}} + T_{\text{KDF}} + T_{\text{Hash}}
\end{align}

The total handshake latency is:
% 【中文翻译】总握手延迟为：

\begin{equation}
T_{\text{handshake}} = T_{\text{crypto}}^{\text{client}} + T_{\text{crypto}}^{\text{relay}} + \text{RTT}
\end{equation}

In SAGIN deployments, minimizing $T_{\text{crypto}}$ remains critical despite RTT dominance, as:
% 【中文翻译】在SAGIN部署中，尽管RTT占主导地位，最小化T_crypto仍然至关重要，因为：
\begin{itemize}[leftmargin=*]
    \item Circuit building is sequential, multiplying handshake delays by three
    % 【中文翻译】电路建立是顺序的，握手延迟乘以三倍
    \item Resource-constrained satellite/UAV nodes have limited computational capacity
    % 【中文翻译】资源受限的卫星/无人机节点计算能力有限
    \item High user load amplifies per-handshake overhead
    % 【中文翻译】高用户负载放大了每次握手的开销
\end{itemize}

Our evaluation (Section~\ref{sec:evaluation}) measures both $T_{\text{crypto}}$ and $T_{\text{circuit}}$ across 12 representative SAGIN topologies with varying RTT characteristics.
% 【中文翻译】我们的评估（第~\ref{sec:evaluation}节）测量了12个代表性SAGIN拓扑中具有不同RTT特性的T_crypto和T_circuit。
